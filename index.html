<html>
<head>
<title>Uglifoc: Uglify Implementation of Function-Object Consumption Naming </title>
<script type="text/javascript">
var reparseScripts = {
        
  request: function(url) {
    var req = new XMLHttpRequest();
    req.open("GET", url, true);
    req.onreadystatechange = this.awaitResponse;
    req.send(); // async
  },

  awaitResponse: function(event) {
    // |this| is request object
    if (this.readyState === 4) {
      if(this.status === 200) {
        if (this.response != null) {
          reparseScripts.testOne(this.response);
        } else {
          console.error("Server returned 200 ok, but it gave no response object");          
        }
      } else {
        console.error("Server error "+this.status, this, event);
      }
    } // else wait for another call
  },
  
  testOne: function(src) {
    console.log("testOne ", src);
    // We parse the JavaScript ...
    var ast = exports.parse(src);
    console.log("testOne ast", ast);
    // and search the resulting syntax tree for function body nodes.
    Uglifoc.FunctionNamer.getNames(ast);
    //ast = exports.transform(ast, [Uglifoc.foc.bind(Uglifoc)], true)
    
    //renderAsElementTree(ast);
    
  },
};

function renderAsElementTree(ast, tree) {
  tree = tree || document.getElementById("tree");
  if (!ast) {
    put(tree, 'li', ast+" "+typeof(ast));
    return;
  }
  if (typeof(ast) === 'string') {
    put(tree, 'li', ast+" "+typeof(ast));
    return;
  }
  if (typeof(ast[0]) === 'string') {
    var branch = put(tree, "li", ast[0]+" "+typeof(ast));
    var beginRecursionAt = 1;
  } else {
    var branch = put(tree, "li", "statements");
    var beginRecursionAt = 0;
  }
    
  if (ast.length) {
    branch = put(branch, "ul");
    for (var i = beginRecursionAt; i < ast.length; i++) {
      renderAsElementTree(ast[i], branch);
    }  
  }
  
}

var exports = {};

window.addEventListener('load', function testAll() {
  console.log('load');

  var scripts = document.getElementsByTagName("script");
  for(var i = 0; i < scripts.length; i++) {
    var aScript = scripts[i];
    var scrAttr = aScript.getAttribute('src'); 
    if (scrAttr && scrAttr.split('/')[0] === "tests") {
      console.log("found a test "+aScript.getAttribute('src'));
      reparseScripts.request(scrAttr);
    }
  }

}, false);

function require(module) {
  if (!window.module)
    console.log(module+" module is required");
}
</script>
<script type="text/javascript" src="uglify/lib/parse-js.js"></script>
<script type="text/javascript" src="put-selector/put.js"></script>
<script type="text/javascript" src="foc.js"></script>
<!-- <script type="text/javascript" src="tests/Functions.js"></script> -->
<script type="text/javascript" src="tests/paperFigure1.js"></script>
<!--  <script type="text/javascript" src="tests/ObjectPropertyInitializer.js"></script>  

</head>
<body>
<h1>Function-Object Consumption naming algorithm implementation in Uglify</h1>
<p>
Splash Wavefront 2011 Paper:
<a href="http://code.google.com/p/querypoint-debugging/downloads/detail?name=NamingJSFunctions.pdf">
Naming Anonymous JavaScript Functions
</a>, by Salman Mirghasemi,  John J. Barton, and Prof. Claude Petitpierre
</p>
<ul id='tree'></ul>
</body>
</html>