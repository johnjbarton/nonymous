<html>
<head>
<title>Uglifoc: Uglify Implementation of Function-Object Consumption Naming </title>
<script type="text/javascript">
var reparseScripts = {
        
  request: function(url) {
    var req = new XMLHttpRequest();
    req.open("GET", url, true);
    req.onreadystatechange = this.awaitResponse(url);
    req.send(); // async
  },

  awaitResponse: function(url) {
    return function(event) {
      // |this| is request object
      if (this.readyState === 4) {
        if(this.status === 200) {
          if (this.response != null) {
            reparseScripts.reportNames(url, this.response);
          } else {
            console.error("Server returned 200 ok, but it gave no response object");          
          }
        } else {
          console.error("Server error "+this.status, this, event);
        }
      } // else wait for another call
    }
  },
  
  reportNames: function(url, src) {
    console.log("testOne "+url, src);
    // We parse the JavaScript ...
    var ast = exports.parse(src, false, ".loc");
    
    // and search the resulting syntax tree for function body nodes.
    var names = Uglifoc.FunctionNamer.getNames(ast);
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      console.log(url+"@"+name.line+"."+name.col+": "+name.name);
    }
    
  },
};

function renderAsElementTree(ast, tree) {
  tree = tree || document.getElementById("tree");
  if (!ast) {
    put(tree, 'li', ast+" "+typeof(ast));
    return;
  }
  if (typeof(ast) === 'string') {
    put(tree, 'li', ast+" "+typeof(ast));
    return;
  }
  if (typeof(ast[0]) === 'string') {
    var branch = put(tree, "li", ast[0]+" "+typeof(ast));
    var beginRecursionAt = 1;
  } else {
    var branch = put(tree, "li", "statements");
    var beginRecursionAt = 0;
  }
    
  if (ast.length) {
    branch = put(branch, "ul");
    for (var i = beginRecursionAt; i < ast.length; i++) {
      renderAsElementTree(ast[i], branch);
    }  
  }
  
}

var exports = {};

window.addEventListener('load', function testAll() {

  var scripts = document.getElementsByTagName("script");
  for(var i = 0; i < scripts.length; i++) {
    var aScript = scripts[i];
    var scrAttr = aScript.getAttribute('src'); 
    if (scrAttr && scrAttr.split('/')[0] === "tests") {
      //console.log("found a test "+aScript.getAttribute('src'));
      reparseScripts.request(scrAttr);
    }
  }

}, false);

function require(module) {
  if (!window.module)
    console.log(module+" module is required");
}
</script>
<script type="text/javascript" src="UglifyJS/lib/parse-js.js"></script>
<script type="text/javascript" src="put-selector/put.js"></script>
<script type="text/javascript" src="foc.js"></script>
<!-- <script type="text/javascript" src="tests/Functions.js"></script> -->
<script type="text/javascript" src="tests/paperFigure1.js"></script>

</head>
<body>
<h1>Function-Object Consumption naming algorithm implementation in Uglify</h1>
<p>
Splash Wavefront 2011 Paper:
<a href="http://code.google.com/p/querypoint-debugging/downloads/detail?name=NamingJSFunctions.pdf">
Naming Anonymous JavaScript Functions
</a>, by Salman Mirghasemi,  John J. Barton, and Prof. Claude Petitpierre
</p>
<ul id='tree'></ul>
</body>
</html>