<html>
<head>
<title>Nonymous: Naming Javascript Functions with the Function-Object Consumption Algorithm </title>
<script type="text/javascript">
var loadAndTest = {
  
  overrides: {},
  
  getNameInfosFromSource: function(src) {
    // We parse the JavaScript ...
    var ast = exports.parse(src, false, ".loc");
    
    // and search the resulting syntax tree for function body nodes.
    var infos = Nonymous.getNames(ast, true, loadAndTest.overrides);
    return infos;
  },
  
  checkNames: function(url, src, infosToCheck) {
    var infos = loadAndTest.getNameInfosFromSource(src);
    var pass = 0;
    var fail = 0;
    var lesser = (infos.length > infosToCheck.length) ? infosToCheck.length : infos.length;
    for (var i = 0; i < lesser; i++) {
      var name = loadAndTest.formName(url, infos[i]);
      if (name === infosToCheck[i]) {
        pass++;
      } else {
        fail++;
        console.log(infosToCheck[i]+" !== "+name);
      }
    }
    for (; i < infosToCheck.length; i++) {
      fail++;
      console.log("missing "+infosToCheck[i])
    }
    if (infos.length > infosToCheck.length) {
      for (var i = infosToCheck.length; i < infos.length; i++) {
        fail++;
        var name = loadAndTest.formName(url, infos[i]);
        console.log("extra "+name);
      }
    }
    console.log(url+" Pass: "+pass+(fail?" Fail: "+fail:""));
  },
  
  formName: function(url, info) {
    return url+"@"+info.line+"."+info.col+": "+info.name
  },
  
  reportNames: function(url, src) {
    console.log("testOne "+url, src);
    var srcLines = src.split('\n');
    var output = new Array(srcLines.length);
    var infos = loadAndTest.getNameInfosFromSource(src);
    for (var i = 0; i < infos.length; i++) {
      var info = infos[i];
      output[info.line] = info.name;
    }
    return output.join('\n');
  },
  
  analyzeOne: function(input) {
    var aScript = input.textContent;
    return this.reportNames(input.id, input.textContent);
  },
  
  hookAll: function() {
    function analyzer(input, output) {
      return function(event) {
        output.textContent = loadAndTest.analyzeOne(input);  
      }
    }

    var outputs = document.getElementsByClassName('output');
    var inputs = document.getElementsByClassName('input');
    for(var i = 0; i < inputs.length; i++) {
      var input = inputs[i];
      var output = outputs[i];
      var analyzeRow = analyzer(input, output);
      input.addEventListener('click', analyzeRow, true);
    }
  },

  testAll: function() {
    var inputs = document.getElementsByClassName('input');
    for(var i = 0; i < inputs.length; i++) {
      var input = inputs[i];
      var e = document.createEvent('MouseEvents');
      e.initEvent('click', true, true);
      input.dispatchEvent(e);
    }
  },

};

var exports = {};


function hookAndTestAll() {
  loadAndTest.hookAll();
  loadAndTest.testAll();
}
window.addEventListener('load', hookAndTestAll, false);

function require(module) {
  if (!window.module)
    console.log(module+" module is required");
}
</script>
<script type="text/javascript" src="UglifyJS/lib/parse-js.js"></script>
<script type="text/javascript" src="nonymous.js"></script>

<style>
body {
  font-family:Verdana,Geneva,sans-serif;
}
table {
  border-collapse:collapse;
}
table, th, td {
  border: 1px solid gray;
  padding: 7px;
}
.output {
  text-align: right;
}
</style>
</head>
<body>
<h1>Nonymous: Function-Object Consumption Naming Algorithm Implementation</h1>
<p>Demo/test page for a proposed way of automatically naming anonymous functions for editors, debuggers, and other tools</p>  
<ul>
<li>Splash Wavefront 2011 Paper:
<a href="http://code.google.com/p/querypoint-debugging/downloads/detail?name=NamingJSFunctions.pdf">
Naming Anonymous JavaScript Functions
</a>, by Salman Mirghasemi,  John J. Barton, and Prof. Claude Petitpierre</li>
<li><a href="https://github.com/johnjbarton/outliner">Orion Editor Plugin Implementation</a>
</ul>

<table>
<tbody>
<tr><th>Naming Algorithm Results</th><th>Input Source</th></tr>
<tr>
  <td>
    <pre class="output"></pre>
  </td>
  <td>
<pre class="input" id="paperFig1">
  var main = function() {             // 1. main
   var foo = new Foo(
      function(){                     // 2. main/foo<
        this.welcome = "Hi!";
      });
   var bar = new Bar("GoodBye.");
   console.log(foo.welcome);
   console.log(bar.message);
  };
  var Foo = function(){               // 3. Foo<
    var instances;
    return function(initializer){     // 4. Foo
        instances++;
        initializer.apply(this);
      };
  }();
  var Baz = Bar = function(msg){      // 5. Bar
    this.message = msg;
  }
</pre>
</td>
</tr>
<tr>
  <td>
    <pre class="output"></pre>
  </td>
  <td>
<pre class="input" id="objects">
  // Case 1: Object Property Initializer

var anObject = {
  aPropertyInitialized: function() {
    return true;
  }
};
function Fuz(){};
Fuz.prototype = {
  add: function(child) {
    this.children.push(child);
  },
}
</pre>
</td>
</tr>
<tr>
  <td>
    <pre class="output"></pre>
  </td>
  <td>
<pre class="input" id="assignment">
var x = 1;
x = function(){};                                                 // x

x = window.addEventListener("something", {onFoo: function(){}});  // x&lt;onFoo

x = window.addEventListener('load', function(event) {}, false);   // x&lt;(load-fal)

addEventListener('load', function(event) {}, false);  // addEventListener(load-fals);
</pre>
</td>
</tr>
<tr>
  <td>
    <pre class="output"></pre>
  </td>
  <td>
<pre class="input" id="define">
define(["uglify-js", "lib/nonymous/nonymous.js"], function(mUglifyJs, mNonymous) {
});
</pre>
</td>
</tr>
</tr>
<tr>
  <td>
    <pre class="output"></pre>
  </td>
  <td>
<pre class="input" id="named">
// Some named functions that we should be finding the names of...
function foo() {
  return 1;
}
var bar = function bax() {
  return 2;
}
</pre>
</td>
</tr>
<tr>
  <td>
    <pre class="output"></pre>
  </td>
  <td>
<pre class="input" id="callNoAssign">
// nested function call with no assignment
function callNoAssign() {
  this.fileClient.fetchChildren(parentItem.ChildrenLocation).then( 
				dojo.hitch(this, function(children) {
					mUtil.processNavigatorParent(parentItem, children);
					onComplete(children);
				})
			);
}
</pre>
</td>
</tr>
<tr>
  <td>
    <pre class="output"></pre>
  </td>
  <td>
<pre class="input" id="otherArgAlsoFunction">
// function in argument with another function argument
function otherArgAlsoFunction() {
  this._convertDelimiter(text, function(t) {clipboadText.push(t);}, function() {clipboadText.push(delimiter);});
}
</pre>
</td>
</tr>
<tr>
  <td>
    <pre class="output"></pre>
  </td>
  <td>
<pre class="input" id="dotty">
  var x = {fox: { bax: function(){} } };	//  fox.bax
  foo.foo.foo = function(){};
  var z = {
    foz: function() {
      var baz = function() {
        var y = {bay: function() {}};  // foz/baz/bay
      };
    }
  };
  var outer = function() {
    x.fox.bax.nx = function(){};
    var w = {fow: { baw: function(){} } };	//  outer/fow.baw
  };
</pre>
</td>
</tr>
</tbody>
</table>
<br>
<table id='markers'>
<caption>Try out different naming marker options:</caption>
<tbody>
<tr><th>Marker</th><th>Role</th></tr>
<tr><td><input id='isPartOfSep' type='text' size='3' value='.'/></td><td>Name component is a property</td></tr>
<tr><td><input id='isContributesToSep' type='text' size='3' value='<'/></td><td>Function contributes to the name component</td></tr>
<tr><td><input id='isInArgSummarySep' type='text' size='3' value='^'/></td><td>Function's location within an argument summary</td></tr>
<tr><td><input id='isScopedSep' type='text' size='3' value='/'/></td><td>Scope separator</td></tr>
<tr><td><input id='isProperySep' type='text' size='3' value='.'/></td><td>Name is enclosed in a property</td></tr>
<tr><td><input id='argSummaryClip' type='text' size='3' value='15'/></td><td>The max number of characters used in an argument summary</td></tr>
</tbody>
</table>
<script type="text/javascript">
function override(event) {
  var property = event.target.getAttribute('id');
  var value = event.target.value;
  if (value && Nonymous[property]) {
    if (typeof Nonymous[property] === 'number') {
      value = parseInt(value);
    }
    loadAndTest.overrides[property] = value;
    loadAndTest.testAll();
  }
}
function hookInputs() {
  var markers = document.getElementById('markers');
  markers.addEventListener('keyup', override, true);
}
window.addEventListener('load', hookInputs, false);
</script>
</body>
</html>
